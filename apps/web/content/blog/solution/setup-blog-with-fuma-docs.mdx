---
title: Setup a Blog with NextJS & Fuma Docs
description: A guide to build a blog using Fuma Docs
date: 2025-04-16
author: rajiv
tags: [tutorial, social-media, x-twitter, component]
image: https://shadcnblocks.com/images/block/placeholder-5.svg
draft: true
---

What features would you want on your blog? I went for following:

## Features

- [x] Static Site which I can publish to Github Pages
- [x] MDX Support: I code frontend too, so I need something where I can embed React Components
- [x] Search
- [x] Table of Contents: The clerk style

### Other Features

- [x] A Blog Post
- [x] List of Posts with Pagination
- [x] Categories
- [x] Series
- [ ] Tags (WIP)
- [x] Metadata with Social Images
- [x] Static (I am repeating for effect)

## Setup

FumaDocs official docs has an article on how to setup a blog: [Setup a Blog](https://fumadocs.vercel.app/blog/make-a-blog). Using that as foundation I have built my blog with above features.

You can go about this in two ways:

- Clone the current repo
- Follow the steps below to add to your existing nextjs site

### Install and Configure Fuma Docs

<Steps>

<Step>

### Install Fuma Docs

You need a working setup of Fuma Docs. If you don't have one, you can create one using the following command:

```package-install
pnpm create fumadocs-app
```

Or you can configure fumadocs [manually](https://fumadocs.vercel.app/docs/ui/manual-installation)

At this point you should have basic setup ready with files: source.config.ts and lib/source.ts

### Setup ShadCN Components

If you are already have shadcn setup, you don't need to run the following command.

```bash
pnpm dlx shadcn@latest init
```

We need following components:

- button
- popover
- badge
- card

You can add above just with following:

```bash
pnpm dlx shadcn@latest add button popover badge card
```

We also need a **book** icon component which we use while showing series:

```bash
pnpm dlx shadcn@latest add "https://21st.dev/r/designali-in/book"
```

</Step>

<Step>

### Define a Collection for Blog

We are going to install zod as we are going to use it add frontmatter schema.

```package-install
zod
```

Now define a collection for blog

```ts title="source.config.ts"
import {
  defineDocs,
  defineConfig,
  defineCollections,
  frontmatterSchema,
} from "fumadocs-mdx/config";
import { z } from "zod";

export const blog = defineCollections({
  type: "doc",
  dir: "content/blog",
  schema: frontmatterSchema.extend({
    author: z.string(),
    date: z
      .string()
      .or(z.date())
      .transform((value, context) => {
        try {
          return new Date(value);
        } catch {
          context.addIssue({
            code: z.ZodIssueCode.custom,
            message: "Invalid date",
          });
          return z.NEVER;
        }
      }),
    tags: z.array(z.string()).optional(),
    image: z.string().optional(),
    draft: z.boolean().optional().default(false),
    series: z.string().optional(),
    seriesPart: z.number().optional(),
  }),
});
```

Add following to lib/source.ts

```ts title="lib/source.ts"
import { docs, blog } from "@/.source";
import { loader } from "fumadocs-core/source";
import { createMDXSource } from "fumadocs-mdx";

export const blogSource = loader({
  baseUrl: "/blog",
  source: createMDXSource(blog),
});

export const {
  getPage: getBlogPost,
  getPages: getBlogPosts,
  pageTree: pageBlogTree,
} = blogSource;

export type BlogPost = ReturnType<typeof getBlogPost>;
```

</Step>

<Step>

### Copy fumadocs-blog folder

Add all of above features for a blog would need multiple files to be configured, so we will copy the `fumadocs-blog` folder from this repo.

```bash
npx giget gh:rjvim/rjvim.github.io/packages/fumadocs-blog/src fumadocs-blog --force
@import "../fumadocs-blog/styles/globals.css";
```

```bash
npx giget gh:rjvim/rjvim.github.io/apps/web/app/\(home\)/blog app/\(home\)/blog --force
sed -i '' 's|@repo/fumadocs-blog/blog|@/fumadocs-blog|g' 'app/(home)/blog/[[...slug]]/page.tsx'
```

```bash
npx giget gh:rjvim/rjvim.github.io/apps/web/app/blog-og app/blog-og --force
sed -i '' 's|@repo/fumadocs-blog/blog|@/fumadocs-blog|g' 'app/blog-og/[[...slug]]/route.tsx'
```

```bash
npx giget gh:rjvim/rjvim.github.io/apps/web/blog-components.tsx / --force
```

```tsx title="blog-components.tsx"
import type { Metadata } from "next/types";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Badge } from "@/components/ui/badge";
import { Book } from "@/components/ui/book";
import { Card } from "@/components/ui/card";
import type { BlogConstants, BlogConfiguration } from "@/fumadocs-blog";
import { PostCard } from "@/fumadocs-blog";
import {
  Brain,
  Book as LucideBook,
  Code,
  Cog,
  Lightbulb,
  Megaphone,
  Rocket,
  Users,
  Wrench,
  BookIcon,
} from "lucide-react";

// Blog text constants that can be customized

export const blogConstants: BlogConstants = {
  // General
  blogTitle: "Blog",
  blogDescription: "Articles and thoughts",
  siteName: "myblog.com",
  defaultAuthorName: "My Name",
  xUsername: "@my_x_username",
  // Pagination
  paginationTitle: (page: number) => `Blog - Page ${page}`,
  paginationDescription: (page: number) =>
    `Articles and thoughts - Page ${page}`,
  categoryPaginationTitle: (category: string, page: number) =>
    `${category.charAt(0).toUpperCase() + category.slice(1)} - Page ${page}`,
  categoryPaginationDescription: (category: string, page: number) =>
    `Articles in the ${category} category - Page ${page}`,
  // URLs
  blogBase: "/blog",
  blogOgImageBase: "blog-og",
  pageSize: 5,
};

export function createBlogMetadata(
  override: Metadata,
  blogConstants: BlogConstants
): Metadata {
  // Derive values from the core properties
  const siteUrl = `https://${blogConstants.siteName}`;
  const author = {
    name: blogConstants.defaultAuthorName,
    url: siteUrl,
  };
  const creator = blogConstants.defaultAuthorName;

  return {
    ...override,
    authors: [author],
    creator: creator,
    openGraph: {
      title: override.title ?? undefined,
      description: override.description ?? undefined,
      url: siteUrl,
      siteName: blogConstants.siteName,
      ...override.openGraph,
    },
    twitter: {
      card: "summary_large_image",
      site: blogConstants.xUsername,
      creator: blogConstants.xUsername,
      title: override.title ?? undefined,
      description: override.description ?? undefined,
      ...override.twitter,
    },
    alternates: {
      canonical: "/",
      types: {
        "application/rss+xml": "/api/rss.xml",
      },
      ...override.alternates,
    },
  };
}

export function getBlogConfiguration(): BlogConfiguration {
  return {
    PostCard: PostCard,
    Button,
    Popover,
    PopoverContent,
    PopoverTrigger,
    Badge,
    Book,
    Card,
    cn,
    config: {
      blogBase: blogConstants.blogBase,
      blogOgImageBase: blogConstants.blogOgImageBase,
      pageSize: 5,
    },
  };
}

export const useBlogConfiguration = getBlogConfiguration;

// Moved from lib/categories.ts
export const getCategoryBySlug = (slug: string) => {
  const categories = {
    idea: {
      label: "Idea",
      icon: Brain,
      description:
        "Exploratory thoughts and wild concepts for Teurons and beyond.",
    },
    opinions: {
      label: "Opinions",
      icon: Megaphone,
      description:
        "Subjective, wild, gut-hunch takesâ€”less informed, out-of-box rants.",
    },
  };

  return (
    categories[slug as keyof typeof categories] || {
      label: slug.toString().replace(/-/g, " ").toLowerCase(),
      icon: BookIcon,
    }
  );
};

export const getSeriesBySlug = (slug: string) => {
  const series = {
    x: {
      label: "Series X",
      icon: LucideBook,
      description: "A Sample Series",
    },
    // Add more series here as needed
  };

  return (
    series[slug as keyof typeof series] || {
      label: slug.charAt(0).toUpperCase() + slug.slice(1),
      icon: LucideBook,
      description: `Articles in the ${
        slug.charAt(0).toUpperCase() + slug.slice(1)
      } series.`,
    }
  );
};
```

Add following sample post

````mdx title="content/blog/idea/zero-trust-security.mdx"
---
title: Zero Trust Security
description: Why modern security architectures assume breach and verify everything
author: lina
date: 2025-03-22
tags: [security, zero trust, cybersecurity, enterprise]
image: https://shadcnblocks.com/images/block/placeholder-5.svg
---

# Zero Trust Security

Traditional security models operated on the principle of "trust but verify" and focused on perimeter defense. Zero Trust flips this paradigm with a simple principle: never trust, always verify.

## Core Principles

Zero Trust is built on several foundational ideas:

### Assume Breach

Zero Trust architectures operate under the assumption that attackers are already present within the network.

### Verify Explicitly

Every access request must be fully authenticated, authorized, and encrypted:

1. Strong identity verification for all users
2. Device health validation
3. Just-in-time and just-enough access
4. Context-aware policies

## Implementation Strategies

Moving to Zero Trust requires systematic changes:

### Identity as the Control Plane

Modern security centers on identity rather than network location:

```yaml
# Example access policy
resources:
  - id: financial-dashboard
    access_rules:
      - condition:
          user:
            groups: ["finance-team"]
            authentication:
              mfa: required
          device:
            compliance: verified
            encryption: enabled
          context:
            location: approved
            risk_score: low
        permission: allow
```
````

### Micro-Segmentation

Network security shifts from perimeter-based to fine-grained segmentation between workloads.

````

</Step>

<Step>

### Add mdx-components

```tsx title="mdx-components.tsx"
import defaultMdxComponents from "fumadocs-ui/mdx";
import type { MDXComponents } from "mdx/types";

export function getMDXComponents(components?: MDXComponents): MDXComponents {
  return {
    ...defaultMdxComponents,
    ...components,
  };
}
````

</Step>

<Step>

### Configure next.config.mjs

_Yes, it's .mjs_

Remember we are building a static blog, so we need to set "export"

```ts title="next.config.mjs"
import { createMDX } from "fumadocs-mdx/next";

const withMDX = createMDX();

/** @type {import('next').NextConfig} */
const config = {
  reactStrictMode: true,
  output: "export",
  images: { unoptimized: true },
};

export default withMDX(config);
```

</Step>

<Step>

### Configure RootProvider

```tsx title="app/layout.tsx"
import { RootProvider } from "fumadocs-ui/provider";

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <RootProvider
      search={{
        options: {
          type: "static",
        },
      }}
    >
      {children}
    </RootProvider>
  );
}
```

</Step>

<Step>

### Add source.config.ts

Here we declare `dir: "content/blog",` which is the directory where our markdown files are located.

<include lang="ts" meta='title="source.config.ts"'>
  ../../../source.config.ts
</include>

</Step>

<Step>

### Add source.ts

The meat of the solution. Here we are using `loader` to create a source for our blog.

<include lang="ts" meta='title="source.ts"'>
  ../../../lib/source.ts
</include>  
</Step>

<Step>
### Copy helper library for blog

</Step>

</Steps>
